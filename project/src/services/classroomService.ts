import { supabase } from '../lib/supabase';

// ============================================
// TYPES & INTERFACES
// ============================================

export interface ClassroomClass {
  id: string;
  teacher_id: string;
  class_name: string;
  subject?: string;
  section?: string;
  room?: string;
  description?: string;
  class_code: string;
  banner_color?: string;
  created_at: string;
  updated_at: string;
  student_count?: number;
  assignment_count?: number;
}

export interface ClassEnrollment {
  id: string;
  class_id: string;
  student_id: string;
  status: string;
  enrolled_at: string;
}

export interface ClassAssignment {
  id: string;
  class_id: string;
  teacher_id: string;
  title: string;
  description?: string;
  instructions?: string;
  due_date?: string;
  points: number;
  attachment_url?: string;
  attachment_name?: string;
  status: string;
  created_at: string;
  updated_at: string;
}

export interface AssignmentSubmission {
  id: string;
  assignment_id: string;
  student_id: string;
  submission_text?: string;
  attachment_url?: string;
  attachment_name?: string;
  status: string;
  grade?: number;
  feedback?: string;
  submitted_at?: string;
  graded_at?: string;
  created_at: string;
  updated_at: string;
}

export interface ClassAnnouncement {
  id: string;
  class_id: string;
  teacher_id: string;
  content: string;
  attachment_url?: string;
  attachment_name?: string;
  created_at: string;
  updated_at: string;
}

export interface ClassMaterial {
  id: string;
  class_id: string;
  teacher_id: string;
  title: string;
  description?: string;
  file_url: string;
  file_name?: string;
  file_type?: string;
  created_at: string;
}

// ============================================
// TEACHER FUNCTIONS
// ============================================

export const classroomService = {

  // Create a new class (code is auto-generated by database trigger)
  async createClass(classData: {
    teacher_id: string;
    class_name: string;
    subject?: string;
    section?: string;
    room?: string;
    description?: string;
    banner_color?: string;
  }): Promise<ClassroomClass | null> {
    try {
      const { data, error } = await supabase
        .from('classroom_classes')
        .insert([classData])
        .select()
        .single();

      if (error) {
        console.error('Error creating class:', error);
        throw error;
      }
      return data as ClassroomClass;
    } catch (error) {
      console.error('Error in createClass:', error);
      return null;
    }
  },

  // Get all classes for a teacher
  async getTeacherClasses(teacherId: string): Promise<ClassroomClass[]> {
    try {
      const { data, error } = await supabase
        .from('classroom_class_stats')
        .select('*')
        .eq('teacher_id', teacherId)
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Error fetching teacher classes:', error);
        throw error;
      }
      return data as ClassroomClass[];
    } catch (error) {
      console.error('Error in getTeacherClasses:', error);
      return [];
    }
  },

  // Get specific class details
  async getClassDetails(classId: string): Promise<ClassroomClass | null> {
    try {
      const { data, error } = await supabase
        .from('classroom_classes')
        .select('*')
        .eq('id', classId)
        .single();

      if (error) {
        console.error('Error fetching class details:', error);
        throw error;
      }
      return data as ClassroomClass;
    } catch (error) {
      console.error('Error in getClassDetails:', error);
      return null;
    }
  },

  // Update class information
  async updateClass(classId: string, updates: Partial<ClassroomClass>): Promise<ClassroomClass | null> {
    try {
      const { data, error } = await supabase
        .from('classroom_classes')
        .update(updates)
        .eq('id', classId)
        .select()
        .single();

      if (error) {
        console.error('Error updating class:', error);
        throw error;
      }
      return data as ClassroomClass;
    } catch (error) {
      console.error('Error in updateClass:', error);
      return null;
    }
  },

  // Delete a class
  async deleteClass(classId: string): Promise<boolean> {
    try {
      const { error } = await supabase
        .from('classroom_classes')
        .delete()
        .eq('id', classId);

      if (error) {
        console.error('Error deleting class:', error);
        throw error;
      }
      return true;
    } catch (error) {
      console.error('Error in deleteClass:', error);
      return false;
    }
  },

  // Create an assignment
  async createAssignment(assignmentData: {
    class_id: string;
    teacher_id: string;
    title: string;
    description?: string;
    instructions?: string;
    due_date?: string;
    points?: number;
    attachment_url?: string;
    attachment_name?: string;
  }): Promise<ClassAssignment | null> {
    try {
      const { data, error } = await supabase
        .from('classroom_assignments')
        .insert([{ ...assignmentData, status: 'assigned' }])
        .select()
        .single();

      if (error) {
        console.error('Error creating assignment:', error);
        throw error;
      }
      return data as ClassAssignment;
    } catch (error) {
      console.error('Error in createAssignment:', error);
      return null;
    }
  },

  // Get all assignments for a class
  async getClassAssignments(classId: string): Promise<ClassAssignment[]> {
    try {
      const { data, error } = await supabase
        .from('classroom_assignments')
        .select('*')
        .eq('class_id', classId)
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Error fetching assignments:', error);
        throw error;
      }
      return data as ClassAssignment[];
    } catch (error) {
      console.error('Error in getClassAssignments:', error);
      return [];
    }
  },

  // Update assignment
  async updateAssignment(assignmentId: string, updates: Partial<ClassAssignment>): Promise<ClassAssignment | null> {
    try {
      const { data, error } = await supabase
        .from('classroom_assignments')
        .update(updates)
        .eq('id', assignmentId)
        .select()
        .single();

      if (error) {
        console.error('Error updating assignment:', error);
        throw error;
      }
      return data as ClassAssignment;
    } catch (error) {
      console.error('Error in updateAssignment:', error);
      return null;
    }
  },

  // Delete assignment
  async deleteAssignment(assignmentId: string): Promise<boolean> {
    try {
      const { error } = await supabase
        .from('classroom_assignments')
        .delete()
        .eq('id', assignmentId);

      if (error) {
        console.error('Error deleting assignment:', error);
        throw error;
      }
      return true;
    } catch (error) {
      console.error('Error in deleteAssignment:', error);
      return false;
    }
  },

  // Get all submissions for an assignment
  async getAssignmentSubmissions(assignmentId: string): Promise<AssignmentSubmission[]> {
    try {
      const { data, error } = await supabase
        .from('classroom_submissions')
        .select('*')
        .eq('assignment_id', assignmentId)
        .order('submitted_at', { ascending: false });

      if (error) {
        console.error('Error fetching submissions:', error);
        throw error;
      }
      return data as AssignmentSubmission[];
    } catch (error) {
      console.error('Error in getAssignmentSubmissions:', error);
      return [];
    }
  },

  // Grade a submission
  async gradeSubmission(submissionId: string, grade: number, feedback?: string): Promise<AssignmentSubmission | null> {
    try {
      const { data, error } = await supabase
        .from('classroom_submissions')
        .update({
          grade,
          feedback,
          status: 'graded',
          graded_at: new Date().toISOString()
        })
        .eq('id', submissionId)
        .select()
        .single();

      if (error) {
        console.error('Error grading submission:', error);
        throw error;
      }
      return data as AssignmentSubmission;
    } catch (error) {
      console.error('Error in gradeSubmission:', error);
      return null;
    }
  },

  // Create announcement
  async createAnnouncement(announcementData: {
    class_id: string;
    teacher_id: string;
    content: string;
    attachment_url?: string;
    attachment_name?: string;
  }): Promise<ClassAnnouncement | null> {
    try {
      const { data, error } = await supabase
        .from('classroom_announcements')
        .insert([announcementData])
        .select()
        .single();

      if (error) {
        console.error('Error creating announcement:', error);
        throw error;
      }
      return data as ClassAnnouncement;
    } catch (error) {
      console.error('Error in createAnnouncement:', error);
      return null;
    }
  },

  // Get class announcements
  async getClassAnnouncements(classId: string): Promise<ClassAnnouncement[]> {
    try {
      const { data, error } = await supabase
        .from('classroom_announcements')
        .select('*')
        .eq('class_id', classId)
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Error fetching announcements:', error);
        throw error;
      }
      return data as ClassAnnouncement[];
    } catch (error) {
      console.error('Error in getClassAnnouncements:', error);
      return [];
    }
  },

  // Delete announcement
  async deleteAnnouncement(announcementId: string): Promise<boolean> {
    try {
      const { error } = await supabase
        .from('classroom_announcements')
        .delete()
        .eq('id', announcementId);

      if (error) {
        console.error('Error deleting announcement:', error);
        throw error;
      }
      return true;
    } catch (error) {
      console.error('Error in deleteAnnouncement:', error);
      return false;
    }
  },

  // Get enrolled students in a class
  async getClassStudents(classId: string): Promise<any[]> {
    try {
      const { data, error } = await supabase
        .from('classroom_enrollments')
        .select('*')
        .eq('class_id', classId)
        .eq('status', 'active')
        .order('enrolled_at', { ascending: true });

      if (error) {
        console.error('Error fetching class students:', error);
        throw error;
      }
      return data || [];
    } catch (error) {
      console.error('Error in getClassStudents:', error);
      return [];
    }
  },

  // Remove student from class
  async removeStudent(classId: string, studentId: string): Promise<boolean> {
    try {
      const { error } = await supabase
        .from('classroom_enrollments')
        .delete()
        .eq('class_id', classId)
        .eq('student_id', studentId);

      if (error) {
        console.error('Error removing student:', error);
        throw error;
      }
      return true;
    } catch (error) {
      console.error('Error in removeStudent:', error);
      return false;
    }
  },

  // ============================================
  // STUDENT FUNCTIONS
  // ============================================

  // Join a class using code
  async joinClassByCode(code: string, studentId: string): Promise<ClassroomClass | null> {
    try {
      // First, find the class by code
      const { data: classData, error: classError } = await supabase
        .from('classroom_classes')
        .select('*')
        .eq('class_code', code.toUpperCase())
        .single();

      if (classError || !classData) {
        console.error('Class not found with code:', code);
        throw new Error('Invalid class code');
      }

      // Check if already enrolled
      const { data: existingEnrollment } = await supabase
        .from('classroom_enrollments')
        .select('*')
        .eq('class_id', classData.id)
        .eq('student_id', studentId)
        .single();

      if (existingEnrollment) {
        throw new Error('Already enrolled in this class');
      }

      // Enroll the student
      const { error: enrollError } = await supabase
        .from('classroom_enrollments')
        .insert([{
          class_id: classData.id,
          student_id: studentId,
          status: 'active'
        }]);

      if (enrollError) {
        console.error('Error enrolling student:', enrollError);
        throw enrollError;
      }

      return classData as ClassroomClass;
    } catch (error) {
      console.error('Error in joinClassByCode:', error);
      return null;
    }
  },

  // Get all classes a student is enrolled in
  async getStudentClasses(studentId: string): Promise<ClassroomClass[]> {
    try {
      const { data, error } = await supabase
        .from('classroom_enrollments')
        .select('*, class:class_id(*)')
        .eq('student_id', studentId)
        .eq('status', 'active')
        .order('enrolled_at', { ascending: false });

      if (error) {
        console.error('Error fetching student classes:', error);
        throw error;
      }

      // Extract the class data from the enrollment records
      return data?.map((enrollment: any) => enrollment.class) || [];
    } catch (error) {
      console.error('Error in getStudentClasses:', error);
      return [];
    }
  },

  // Submit an assignment
  async submitAssignment(submissionData: {
    assignment_id: string;
    student_id: string;
    submission_text?: string;
    attachment_url?: string;
    attachment_name?: string;
  }): Promise<AssignmentSubmission | null> {
    try {
      // Check if submission already exists
      const { data: existingSubmission } = await supabase
        .from('classroom_submissions')
        .select('*')
        .eq('assignment_id', submissionData.assignment_id)
        .eq('student_id', submissionData.student_id)
        .single();

      if (existingSubmission) {
        // Update existing submission
        const { data, error } = await supabase
          .from('classroom_submissions')
          .update({
            submission_text: submissionData.submission_text,
            attachment_url: submissionData.attachment_url,
            attachment_name: submissionData.attachment_name,
            status: 'submitted',
            submitted_at: new Date().toISOString()
          })
          .eq('id', existingSubmission.id)
          .select()
          .single();

        if (error) {
          console.error('Error updating submission:', error);
          throw error;
        }
        return data as AssignmentSubmission;
      } else {
        // Create new submission
        const { data, error } = await supabase
          .from('classroom_submissions')
          .insert([{
            ...submissionData,
            status: 'submitted',
            submitted_at: new Date().toISOString()
          }])
          .select()
          .single();

        if (error) {
          console.error('Error creating submission:', error);
          throw error;
        }
        return data as AssignmentSubmission;
      }
    } catch (error) {
      console.error('Error in submitAssignment:', error);
      return null;
    }
  },

  // Get student's submissions
  async getStudentSubmissions(studentId: string, assignmentId?: string): Promise<AssignmentSubmission[]> {
    try {
      let query = supabase
        .from('classroom_submissions')
        .select('*')
        .eq('student_id', studentId);

      if (assignmentId) {
        query = query.eq('assignment_id', assignmentId);
      }

      const { data, error } = await query.order('created_at', { ascending: false });

      if (error) {
        console.error('Error fetching student submissions:', error);
        throw error;
      }
      return data as AssignmentSubmission[];
    } catch (error) {
      console.error('Error in getStudentSubmissions:', error);
      return [];
    }
  },

  // Get student's submission for specific assignment
  async getStudentAssignmentSubmission(studentId: string, assignmentId: string): Promise<AssignmentSubmission | null> {
    try {
      const { data, error } = await supabase
        .from('classroom_submissions')
        .select('*')
        .eq('student_id', studentId)
        .eq('assignment_id', assignmentId)
        .single();

      if (error && error.code !== 'PGRST116') { // PGRST116 is "not found" error
        console.error('Error fetching submission:', error);
        throw error;
      }
      return data as AssignmentSubmission | null;
    } catch (error) {
      console.error('Error in getStudentAssignmentSubmission:', error);
      return null;
    }
  },

  // Unenroll from class
  async unenrollFromClass(classId: string, studentId: string): Promise<boolean> {
    try {
      const { error } = await supabase
        .from('classroom_enrollments')
        .delete()
        .eq('class_id', classId)
        .eq('student_id', studentId);

      if (error) {
        console.error('Error unenrolling from class:', error);
        throw error;
      }
      return true;
    } catch (error) {
      console.error('Error in unenrollFromClass:', error);
      return false;
    }
  },

  // ============================================
  // SHARED FUNCTIONS
  // ============================================

  // Upload material
  async uploadMaterial(materialData: {
    class_id: string;
    teacher_id: string;
    title: string;
    description?: string;
    file_url: string;
    file_name?: string;
    file_type?: string;
  }): Promise<ClassMaterial | null> {
    try {
      const { data, error } = await supabase
        .from('classroom_materials')
        .insert([materialData])
        .select()
        .single();

      if (error) {
        console.error('Error uploading material:', error);
        throw error;
      }
      return data as ClassMaterial;
    } catch (error) {
      console.error('Error in uploadMaterial:', error);
      return null;
    }
  },

  // Get class materials
  async getClassMaterials(classId: string): Promise<ClassMaterial[]> {
    try {
      const { data, error } = await supabase
        .from('classroom_materials')
        .select('*')
        .eq('class_id', classId)
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Error fetching materials:', error);
        throw error;
      }
      return data as ClassMaterial[];
    } catch (error) {
      console.error('Error in getClassMaterials:', error);
      return [];
    }
  },

  // Delete material
  async deleteMaterial(materialId: string): Promise<boolean> {
    try {
      const { error } = await supabase
        .from('classroom_materials')
        .delete()
        .eq('id', materialId);

      if (error) {
        console.error('Error deleting material:', error);
        throw error;
      }
      return true;
    } catch (error) {
      console.error('Error in deleteMaterial:', error);
      return false;
    }
  },

  // Get class by code (for validation)
  async getClassByCode(code: string): Promise<ClassroomClass | null> {
    try {
      const { data, error } = await supabase
        .from('classroom_classes')
        .select('*')
        .eq('class_code', code.toUpperCase())
        .single();

      if (error) {
        console.error('Class not found:', error);
        return null;
      }
      return data as ClassroomClass;
    } catch (error) {
      console.error('Error in getClassByCode:', error);
      return null;
    }
  },

  // ============================================
  // FILE UPLOAD UTILITY
  // ============================================

  // Upload a file to Supabase storage
  async uploadFile(file: File, folder: 'announcements' | 'assignments' | 'submissions' | 'materials'): Promise<{ url: string; name: string } | null> {
    try {
      const fileExt = file.name.split('.').pop();
      const fileName = `${Date.now()}_${Math.random().toString(36).substring(7)}.${fileExt}`;
      const filePath = `classroom/${folder}/${fileName}`;

      const { error } = await supabase.storage
        .from('classroom-files')
        .upload(filePath, file);

      if (error) {
        console.error('Error uploading file:', error);
        throw error;
      }

      // Get public URL
      const { data: publicData } = supabase.storage
        .from('classroom-files')
        .getPublicUrl(filePath);

      return {
        url: publicData.publicUrl,
        name: file.name
      };
    } catch (error) {
      console.error('Error in uploadFile:', error);
      return null;
    }
  }
};
